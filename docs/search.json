[
  {
    "objectID": "0_setup.html",
    "href": "0_setup.html",
    "title": "Install and set up R and RStudio",
    "section": "",
    "text": "Before the workshop starts, you’ll need to install both R (the programming language) and RStudio (the editor/IDE we’ll use to interact with R). If you can, you should also install two R packages. The instructions to do so follow below."
  },
  {
    "objectID": "0_setup.html#install-r-and-rstudio",
    "href": "0_setup.html#install-r-and-rstudio",
    "title": "Install and set up R and RStudio",
    "section": "1 Install R and RStudio",
    "text": "1 Install R and RStudio\n\nWindowsMacOSLinux\n\n\nInstallation on Windows:\n\nInstall R: download and run this .exe file from CRAN.\nInstall RStudio: Click the download button below “Install RStudio” on this page.\n\nThe video below goes through this process:\n\n\n\n\n\n\nInstall as administrator if possible\n\n\n\nNote that if you have separate user and admin accounts, you should run the installers as administrator (right-click on the .exe file and select “Run as administrator” instead of double-clicking). Otherwise problems may occur later, for example when installing R packages.\n\n\n\n\n\nInstallation on MacOS:\n\nInstall R: download and run this .pkg file from CRAN.\nInstall RStudio: Click the download button below “Install RStudio” on this page.\n\nThe video below goes through this process:\n\n\n\nInstallation on Linux:\n\nInstall R: Instructions for R installation on various Linux platforms (Debian, Fedora, Redhat, and Ubuntu) can be found at https://cran.r-project.org/bin/linux/.\nInstall RStudio: Click the download button below “Install RStudio” on this page."
  },
  {
    "objectID": "0_setup.html#install-two-r-packages",
    "href": "0_setup.html#install-two-r-packages",
    "title": "Install and set up R and RStudio",
    "section": "2 Install two R packages",
    "text": "2 Install two R packages\nIf you are comfortable doing so, please install two so-called R packages (basically, add-ons to the functionality of the language) that we will be using during the workshop:\n\nOpen RStudio on your computer\nIn RStudio, find the R “Console”: this is one of the tabs in the bottom left pane\nType or paste the following commands in the Console, pressing Enter (Return) after each:\n\ninstall.packages(\"gapminder\")\ninstall.packages(\"tidyverse\")\n\nYou should see lots of text stream by in the Console while the installation is going on. When it’s done, test that the packages were successfully installed:\n\nlibrary(gapminder)\nlibrary(tidyverse)\n\nThe first command should produce no output, but the second should, similar to what’s shown in this screenshot:"
  },
  {
    "objectID": "3_dplyr.html#the-dplyr-package-and-the-tidyverse",
    "href": "3_dplyr.html#the-dplyr-package-and-the-tidyverse",
    "title": "Data frame manipulation with dplyr",
    "section": "1 The dplyr package and the tidyverse",
    "text": "1 The dplyr package and the tidyverse\nThe dplyr package provides a number of very useful functions for manipulating data frames.\nHere we’re going to cover some of the most commonly used functions, and will also use pipes (%&gt;%) to combine them.\n\nselect() to pick columns (variables)\nfilter() to pick rows (observations)\nrename() to change column names\narrange() to change the order of rows (i.e., to sort a data frame)\nmutate() to modify values in columns and create new columns\nsummarize() (with group_by()) to compute summaries across rows\n\nImportantly, all these functions take a data frame as the input, and return a new, modified data frame as the output.\ndplyr belongs to a broader family of R packages designed for “dataframe-centric” data science called the “Tidyverse”. The other tidyverse package that we’ll cover in today’s workshop is ggplot2 for making plots. You can find more information about the Tidyverse here: https://www.tidyverse.org/.\nAll of the tidyverse’s packages can be loaded at once as follows:\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nThat will print quote some output which tells you which packages have been loaded as part of the tidyverse, and which tidyverse functions “conflict with” (in the sense of having the same name as) R functions that were already in your environment."
  },
  {
    "objectID": "3_dplyr.html#the-gapminder-data-set",
    "href": "3_dplyr.html#the-gapminder-data-set",
    "title": "Data frame manipulation with dplyr",
    "section": "2 The gapminder data set",
    "text": "2 The gapminder data set\nIn this section and in the afternoon, we will work with the gapminder data set. This data set is available in a package (while most packages are built around functions so as to extend R’s functionality, others, like this one, merely contain data sets), and we can load it as follows:\n\nlibrary(gapminder)\n\nLet’s take a look at the dataset, which is stored in a data frame also called gapminder:\n\ngapminder\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\nThe gapminder data frame is a so-called “tibble”, which is the tidyverse version of a data frame. The main difference is the nicer default printing behavior of tibbles: e.g. the data types of columns are shown, and only a limited number of rows will be printed (hence 1,694 more rows).\nAs for the dataset itself, note that each row contains some data for a single country in a specific year (across 5-year intervals between 1952 and 2007):\n\nlifeExp is the life expectancy in years\npop is the population size\ngdpPercap is the per-capita GDP"
  },
  {
    "objectID": "3_dplyr.html#select-to-pick-columns-variables",
    "href": "3_dplyr.html#select-to-pick-columns-variables",
    "title": "Data frame manipulation with dplyr",
    "section": "3 select() to pick columns (variables)",
    "text": "3 select() to pick columns (variables)\nTo subset a data frame by keeping or removing certain columns, we can use the select() function.\nBy default, this function will only keep the columns that you specify, which you typically do simply by listing those columns by name:\n\nselect(.data = gapminder, year, country, gdpPercap)\n\n# A tibble: 1,704 × 3\n    year country     gdpPercap\n   &lt;int&gt; &lt;fct&gt;           &lt;dbl&gt;\n 1  1952 Afghanistan      779.\n 2  1957 Afghanistan      821.\n 3  1962 Afghanistan      853.\n 4  1967 Afghanistan      836.\n 5  1972 Afghanistan      740.\n 6  1977 Afghanistan      786.\n 7  1982 Afghanistan      978.\n 8  1987 Afghanistan      852.\n 9  1992 Afghanistan      649.\n10  1997 Afghanistan      635.\n# ℹ 1,694 more rows\n\n\nIn the command above, the first argument was the data frame, whereas the other arguments were the (unquoted!) names of columns we wanted to keep.\nThe order of the columns in the output data frame is exactly as you list them in select(), and doesn’t need to be the same as in the input data frame. In other words, select() is also one way to reorder columns. In the example above, we moved year to come before country, for example.\nWe can also specify columns that should be removed, by prefacing their name with a ! (or a -):\n\nselect(.data = gapminder, !continent)\n\n# A tibble: 1,704 × 5\n   country      year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan  1952    28.8  8425333      779.\n 2 Afghanistan  1957    30.3  9240934      821.\n 3 Afghanistan  1962    32.0 10267083      853.\n 4 Afghanistan  1967    34.0 11537966      836.\n 5 Afghanistan  1972    36.1 13079460      740.\n 6 Afghanistan  1977    38.4 14880372      786.\n 7 Afghanistan  1982    39.9 12881816      978.\n 8 Afghanistan  1987    40.8 13867957      852.\n 9 Afghanistan  1992    41.7 16317921      649.\n10 Afghanistan  1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\nThere are also ways to select ranges of columns, and to match columns by their partial names, but that is beyond the scope of this short workshop (check the select() help by typing ?select to learn more about this)."
  },
  {
    "objectID": "3_dplyr.html#rename-to-change-column-names-and-the-pipe",
    "href": "3_dplyr.html#rename-to-change-column-names-and-the-pipe",
    "title": "Data frame manipulation with dplyr",
    "section": "4 rename() to change column names, and the pipe (%>%)",
    "text": "4 rename() to change column names, and the pipe (%&gt;%)\nOur next dplyr function is one of the simplest: rename() to change column names.\nThe syntax to specify the new and old name within the function is new_name = old_name. For example, building on the column selection we did above, we may want to rename the gdpPercap column:\n\ngapminder_sel &lt;- select(.data = gapminder, year, country, gdpPercap)\n\nrename(.data = gapminder_sel, gdp_per_capita = gdpPercap)\n\n# A tibble: 1,704 × 3\n    year country     gdp_per_capita\n   &lt;int&gt; &lt;fct&gt;                &lt;dbl&gt;\n 1  1952 Afghanistan           779.\n 2  1957 Afghanistan           821.\n 3  1962 Afghanistan           853.\n 4  1967 Afghanistan           836.\n 5  1972 Afghanistan           740.\n 6  1977 Afghanistan           786.\n 7  1982 Afghanistan           978.\n 8  1987 Afghanistan           852.\n 9  1992 Afghanistan           649.\n10  1997 Afghanistan           635.\n# ℹ 1,694 more rows\n\n\nIt is common to use several (dplyr) functions in succession to “wrangle” a dataframe into a format, and with the data, that we want. To do so, we could go on like we did above, successively assigning new data frames and moving on to the next step.\nBut there is a nicer way of dong this, using so-called “piping” with a pipe operator: we will use the %&gt;% pipe operator.\nLet’s start by seeing pipes into action with a reformulation of the code we used above to first select 3 columns and then rename 1 of them:\n\ngapminder %&gt;%\n  select(year, country, gdpPercap) %&gt;%\n  rename(gdp_per_capita = gdpPercap)\n\n# A tibble: 1,704 × 3\n    year country     gdp_per_capita\n   &lt;int&gt; &lt;fct&gt;                &lt;dbl&gt;\n 1  1952 Afghanistan           779.\n 2  1957 Afghanistan           821.\n 3  1962 Afghanistan           853.\n 4  1967 Afghanistan           836.\n 5  1972 Afghanistan           740.\n 6  1977 Afghanistan           786.\n 7  1982 Afghanistan           978.\n 8  1987 Afghanistan           852.\n 9  1992 Afghanistan           649.\n10  1997 Afghanistan           635.\n# ℹ 1,694 more rows\n\n\nWhat happened here is that we took the gapminder data frame, pushed (or “piped”) it into the select() function, whose output was in turn piped into the rename() function.\nYou can think of the pipe as “then”: take gapminder, then select, then rename.\nWhen using pipes, piped input replaces our previous way of specifying the input with the .data argument.\nUnder the hood, when you pipe something into a function, this will by default be passed to the first argument of the function. dplyr (and other tidyverse) functions are quite consistent with the first argument always being a data frame, which makes them “pipe-friendly”.\nUsing pipes is slightly less typing and more readable than successive assignments. (It is also faster and uses less computer memory.)"
  },
  {
    "objectID": "3_dplyr.html#filter-to-pick-rows-observations",
    "href": "3_dplyr.html#filter-to-pick-rows-observations",
    "title": "Data frame manipulation with dplyr",
    "section": "5 filter() to pick rows (observations)",
    "text": "5 filter() to pick rows (observations)\nThe filter() function can be used to keep only rows that match a condition. Whereas column-selection often simply happens by column name as we’ve seen with select(), row-selection tends to be a more intricate and interesting topic.\nLet’s start with the following example, where we want to keep observations (remember, these are countries in a given year) that have a life expectancy (column lifeExp) greater than 80 years:\n\ngapminder %&gt;%\n  filter(lifeExp &gt; 80)\n\n# A tibble: 21 × 6\n   country          continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;            &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Australia        Oceania    2002    80.4 19546792    30688.\n 2 Australia        Oceania    2007    81.2 20434176    34435.\n 3 Canada           Americas   2007    80.7 33390141    36319.\n 4 France           Europe     2007    80.7 61083916    30470.\n 5 Hong Kong, China Asia       2002    81.5  6762476    30209.\n 6 Hong Kong, China Asia       2007    82.2  6980412    39725.\n 7 Iceland          Europe     2002    80.5   288030    31163.\n 8 Iceland          Europe     2007    81.8   301931    36181.\n 9 Israel           Asia       2007    80.7  6426679    25523.\n10 Italy            Europe     2002    80.2 57926999    27968.\n# ℹ 11 more rows\n\n\nSo, we specify a condition based on the values in at least one column, and only the rows that satisfy this condition will be kept.\nThese conditions don’t have to be based on numeric comparisons – for example:\n\ngapminder %&gt;%\n  filter(continent == \"Europe\")\n\n# A tibble: 360 × 6\n   country continent  year lifeExp     pop gdpPercap\n   &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;\n 1 Albania Europe     1952    55.2 1282697     1601.\n 2 Albania Europe     1957    59.3 1476505     1942.\n 3 Albania Europe     1962    64.8 1728137     2313.\n 4 Albania Europe     1967    66.2 1984060     2760.\n 5 Albania Europe     1972    67.7 2263554     3313.\n 6 Albania Europe     1977    68.9 2509048     3533.\n 7 Albania Europe     1982    70.4 2780097     3631.\n 8 Albania Europe     1987    72   3075321     3739.\n 9 Albania Europe     1992    71.6 3326498     2497.\n10 Albania Europe     1997    73.0 3428038     3193.\n# ℹ 350 more rows\n\n\n(Remember to use two equals signs == to test for equality!)\n\n5.1 Filter based on multiple conditions\nIt’s also possible to filter based on multiple conditions:\n\ngapminder %&gt;%\n  filter(continent == \"Asia\", year == 2007, lifeExp &gt; 80)\n\n# A tibble: 3 × 6\n  country          continent  year lifeExp       pop gdpPercap\n  &lt;fct&gt;            &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n1 Hong Kong, China Asia       2007    82.2   6980412    39725.\n2 Israel           Asia       2007    80.7   6426679    25523.\n3 Japan            Asia       2007    82.6 127467972    31656.\n\n\nBy default, multiple conditions are combined in an AND fashion — in other words, in a given row, each condition needs to be met for that column to be kept.\nIf you want to combine conditions in an OR fashion, you should use a | as follows:\n\ngapminder %&gt;%\n  filter(lifeExp &gt; 80 | gdpPercap &gt; 10000)\n\n# A tibble: 392 × 6\n   country   continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;     &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Argentina Americas   1977    68.5 26983828    10079.\n 2 Argentina Americas   1997    73.3 36203463    10967.\n 3 Argentina Americas   2007    75.3 40301927    12779.\n 4 Australia Oceania    1952    69.1  8691212    10040.\n 5 Australia Oceania    1957    70.3  9712569    10950.\n 6 Australia Oceania    1962    70.9 10794968    12217.\n 7 Australia Oceania    1967    71.1 11872264    14526.\n 8 Australia Oceania    1972    71.9 13177000    16789.\n 9 Australia Oceania    1977    73.5 14074100    18334.\n10 Australia Oceania    1982    74.7 15184200    19477.\n# ℹ 382 more rows\n\n\nFinally, let’s practice a bit more with pipelines that use multiple dplyr verbs:\n\ngapminder %&gt;%\n  filter(continent == \"Americas\") %&gt;%\n  select(year, country, gdpPercap) %&gt;%\n  rename(gdp_per_capita = gdpPercap)\n\n# A tibble: 300 × 3\n    year country   gdp_per_capita\n   &lt;int&gt; &lt;fct&gt;              &lt;dbl&gt;\n 1  1952 Argentina          5911.\n 2  1957 Argentina          6857.\n 3  1962 Argentina          7133.\n 4  1967 Argentina          8053.\n 5  1972 Argentina          9443.\n 6  1977 Argentina         10079.\n 7  1982 Argentina          8998.\n 8  1987 Argentina          9140.\n 9  1992 Argentina          9308.\n10  1997 Argentina         10967.\n# ℹ 290 more rows\n\n\n \n\n\n5.2 Challenge 1\nWrite a single command (which can span multiple lines and include pipes) that will produce a data frame that has lifeExp, country, and year for Africa but not for other continents. How many rows does your data frame have?\n\n\nClick for the solution\n\n\ngapminder %&gt;%\n  filter(continent == \"Africa\") %&gt;%\n  select(year, country, lifeExp)\n\n# A tibble: 624 × 3\n    year country lifeExp\n   &lt;int&gt; &lt;fct&gt;     &lt;dbl&gt;\n 1  1952 Algeria    43.1\n 2  1957 Algeria    45.7\n 3  1962 Algeria    48.3\n 4  1967 Algeria    51.4\n 5  1972 Algeria    54.5\n 6  1977 Algeria    58.0\n 7  1982 Algeria    61.4\n 8  1987 Algeria    65.8\n 9  1992 Algeria    67.7\n10  1997 Algeria    69.2\n# ℹ 614 more rows\n\n\nIt has 624 rows."
  },
  {
    "objectID": "3_dplyr.html#arrange-to-sort-data-frames",
    "href": "3_dplyr.html#arrange-to-sort-data-frames",
    "title": "Data frame manipulation with dplyr",
    "section": "6 arrange() to sort data frames",
    "text": "6 arrange() to sort data frames\nThe arrange() function is like the sort function in Excel: it changes the order of the rows based on the values in one or more columns. For example, our data set gapminder is currently sorted alphabetically by country and then by year, but we may instead want to sort observations by population size:\n\ngapminder %&gt;%\n  arrange(pop)\n\n# A tibble: 1,704 × 6\n   country               continent  year lifeExp   pop gdpPercap\n   &lt;fct&gt;                 &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt; &lt;int&gt;     &lt;dbl&gt;\n 1 Sao Tome and Principe Africa     1952    46.5 60011      880.\n 2 Sao Tome and Principe Africa     1957    48.9 61325      861.\n 3 Djibouti              Africa     1952    34.8 63149     2670.\n 4 Sao Tome and Principe Africa     1962    51.9 65345     1072.\n 5 Sao Tome and Principe Africa     1967    54.4 70787     1385.\n 6 Djibouti              Africa     1957    37.3 71851     2865.\n 7 Sao Tome and Principe Africa     1972    56.5 76595     1533.\n 8 Sao Tome and Principe Africa     1977    58.6 86796     1738.\n 9 Djibouti              Africa     1962    39.7 89898     3021.\n10 Sao Tome and Principe Africa     1982    60.4 98593     1890.\n# ℹ 1,694 more rows\n\n\nSorting can be useful to see the observations with the smallest or largest values for a certain column: above we see that the country and year with the smallest population size is Sao Tome and Principe in 1952.\nDefault sorting is from small to large, but of course, we may also want to sort in the reverse order. You can do this using the desc() (descending, large-to-small) helper function:\n\ngapminder %&gt;%\n  arrange(desc(pop))\n\n# A tibble: 1,704 × 6\n   country continent  year lifeExp        pop gdpPercap\n   &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;      &lt;int&gt;     &lt;dbl&gt;\n 1 China   Asia       2007    73.0 1318683096     4959.\n 2 China   Asia       2002    72.0 1280400000     3119.\n 3 China   Asia       1997    70.4 1230075000     2289.\n 4 China   Asia       1992    68.7 1164970000     1656.\n 5 India   Asia       2007    64.7 1110396331     2452.\n 6 China   Asia       1987    67.3 1084035000     1379.\n 7 India   Asia       2002    62.9 1034172547     1747.\n 8 China   Asia       1982    65.5 1000281000      962.\n 9 India   Asia       1997    61.8  959000000     1459.\n10 China   Asia       1977    64.0  943455000      741.\n# ℹ 1,694 more rows\n\n\nFinally, it is common to want to sort by multiple columns, where ties in the first column are broken by a second column (and so on) – to do so, simply list the columns in the appropriate order:\n\ngapminder %&gt;%\n  arrange(continent, country)\n\n# A tibble: 1,704 × 6\n   country continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Algeria Africa     1952    43.1  9279525     2449.\n 2 Algeria Africa     1957    45.7 10270856     3014.\n 3 Algeria Africa     1962    48.3 11000948     2551.\n 4 Algeria Africa     1967    51.4 12760499     3247.\n 5 Algeria Africa     1972    54.5 14760787     4183.\n 6 Algeria Africa     1977    58.0 17152804     4910.\n 7 Algeria Africa     1982    61.4 20033753     5745.\n 8 Algeria Africa     1987    65.8 23254956     5681.\n 9 Algeria Africa     1992    67.7 26298373     5023.\n10 Algeria Africa     1997    69.2 29072015     4797.\n# ℹ 1,694 more rows\n\n\nThe above example sorts first by continent and then by country."
  },
  {
    "objectID": "3_dplyr.html#mutate-to-modify-values-in-columns-and-create-new-columns",
    "href": "3_dplyr.html#mutate-to-modify-values-in-columns-and-create-new-columns",
    "title": "Data frame manipulation with dplyr",
    "section": "7 mutate() to modify values in columns and create new columns",
    "text": "7 mutate() to modify values in columns and create new columns\nSo far, we’ve focused on functions that “merely” subset and reorganize data frames. We’ve also seen how we can modify column names. But we haven’t seen how we can change the data or compute derived data in data frames.\nWe can do this with the mutate() function. For example, say that we want to create a new column that has the population size in millions rather than in individuals:\ncalled pop_million that is the result of dividing the values in the pop column by a million.\n\ngapminder %&gt;%\n  mutate(pop_million = pop / 10^6)\n\n# A tibble: 1,704 × 7\n   country     continent  year lifeExp      pop gdpPercap pop_million\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;       &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.        8.43\n 2 Afghanistan Asia       1957    30.3  9240934      821.        9.24\n 3 Afghanistan Asia       1962    32.0 10267083      853.       10.3 \n 4 Afghanistan Asia       1967    34.0 11537966      836.       11.5 \n 5 Afghanistan Asia       1972    36.1 13079460      740.       13.1 \n 6 Afghanistan Asia       1977    38.4 14880372      786.       14.9 \n 7 Afghanistan Asia       1982    39.9 12881816      978.       12.9 \n 8 Afghanistan Asia       1987    40.8 13867957      852.       13.9 \n 9 Afghanistan Asia       1992    41.7 16317921      649.       16.3 \n10 Afghanistan Asia       1997    41.8 22227415      635.       22.2 \n# ℹ 1,694 more rows\n\n\nSo, the code above created a new column called pop_million that is the result of dividing the values in the pop column by a million.\nTo modify a column rather than adding a new one, simply assign back to the same name:\n\ngapminder %&gt;%\n  mutate(pop = pop / 10^6)\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp   pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8.43      779.\n 2 Afghanistan Asia       1957    30.3  9.24      821.\n 3 Afghanistan Asia       1962    32.0 10.3       853.\n 4 Afghanistan Asia       1967    34.0 11.5       836.\n 5 Afghanistan Asia       1972    36.1 13.1       740.\n 6 Afghanistan Asia       1977    38.4 14.9       786.\n 7 Afghanistan Asia       1982    39.9 12.9       978.\n 8 Afghanistan Asia       1987    40.8 13.9       852.\n 9 Afghanistan Asia       1992    41.7 16.3       649.\n10 Afghanistan Asia       1997    41.8 22.2       635.\n# ℹ 1,694 more rows\n\n\n \n\n\n7.1 Challenge 2\nA: Create a new column called gdp_billion that has the absolute GDP (i.e., not relative to population size) in units of billions.\n\n\nClick for the solution\n\n\ngapminder %&gt;%\n    mutate(gdp_billion = gdpPercap * pop / 10^9)\n\n# A tibble: 1,704 × 7\n   country     continent  year lifeExp      pop gdpPercap gdp_billion\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;       &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.        6.57\n 2 Afghanistan Asia       1957    30.3  9240934      821.        7.59\n 3 Afghanistan Asia       1962    32.0 10267083      853.        8.76\n 4 Afghanistan Asia       1967    34.0 11537966      836.        9.65\n 5 Afghanistan Asia       1972    36.1 13079460      740.        9.68\n 6 Afghanistan Asia       1977    38.4 14880372      786.       11.7 \n 7 Afghanistan Asia       1982    39.9 12881816      978.       12.6 \n 8 Afghanistan Asia       1987    40.8 13867957      852.       11.8 \n 9 Afghanistan Asia       1992    41.7 16317921      649.       10.6 \n10 Afghanistan Asia       1997    41.8 22227415      635.       14.1 \n# ℹ 1,694 more rows\n\n\n\nB: (Bonus) Create a new column planet that has the value earth in every row.\n\n\nClick for the solution\n\nIf you simply provide a value, this will be repeated in every row:\n\ngapminder %&gt;%\n  mutate(planet = \"earth\")\n\n# A tibble: 1,704 × 7\n   country     continent  year lifeExp      pop gdpPercap planet\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt; &lt;chr&gt; \n 1 Afghanistan Asia       1952    28.8  8425333      779. earth \n 2 Afghanistan Asia       1957    30.3  9240934      821. earth \n 3 Afghanistan Asia       1962    32.0 10267083      853. earth \n 4 Afghanistan Asia       1967    34.0 11537966      836. earth \n 5 Afghanistan Asia       1972    36.1 13079460      740. earth \n 6 Afghanistan Asia       1977    38.4 14880372      786. earth \n 7 Afghanistan Asia       1982    39.9 12881816      978. earth \n 8 Afghanistan Asia       1987    40.8 13867957      852. earth \n 9 Afghanistan Asia       1992    41.7 16317921      649. earth \n10 Afghanistan Asia       1997    41.8 22227415      635. earth \n# ℹ 1,694 more rows"
  },
  {
    "objectID": "3_dplyr.html#summarize-to-compute-per-group-summary-statistics",
    "href": "3_dplyr.html#summarize-to-compute-per-group-summary-statistics",
    "title": "Data frame manipulation with dplyr",
    "section": "8 summarize() to compute (per-group) summary statistics",
    "text": "8 summarize() to compute (per-group) summary statistics\nIn combination with group_by(), the summarize() function can compute data summaries across groups of rows of a data frame.\nFirst, let’s see what summarize() does when used by itself:\n\ngapminder %&gt;%\n  summarize(mean_gdpPercap = mean(gdpPercap),\n            mean_lifeExp = mean(lifeExp))\n\n# A tibble: 1 × 2\n  mean_gdpPercap mean_lifeExp\n           &lt;dbl&gt;        &lt;dbl&gt;\n1          7215.         59.5\n\n\nAbove, we computed the mean for two columns, across all rows. This is already useful, but in combination with the helper function group_by(), summarize() becomes really powerful.\nFor example, let’s compute the mean GDP and mean life expectancy separately for each continent:\n\ngapminder %&gt;%\n  group_by(continent) %&gt;%\n  summarize(mean_gdpPercap = mean(gdpPercap),\n            mean_lifeExp = mean(lifeExp))\n\n# A tibble: 5 × 3\n  continent mean_gdpPercap mean_lifeExp\n  &lt;fct&gt;              &lt;dbl&gt;        &lt;dbl&gt;\n1 Africa             2194.         48.9\n2 Americas           7136.         64.7\n3 Asia               7902.         60.1\n4 Europe            14469.         71.9\n5 Oceania           18622.         74.3\n\n\ngroup_by() implicitly splits a data frame into groups of rows: here, one group for observations from each continent. After that, operations like in summarize() will happen separately for each group, which is how we ended up with per-continent means.\nFinally, another powerful feature is that we can group by multiple variables – for example, by year and continent:\n\ngapminder %&gt;%\n  group_by(continent, year) %&gt;%\n  summarize(mean_gdpPercap = mean(gdpPercap),\n            mean_lifeExp = mean(lifeExp))\n\n`summarise()` has grouped output by 'continent'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 60 × 4\n# Groups:   continent [5]\n   continent  year mean_gdpPercap mean_lifeExp\n   &lt;fct&gt;     &lt;int&gt;          &lt;dbl&gt;        &lt;dbl&gt;\n 1 Africa     1952          1253.         39.1\n 2 Africa     1957          1385.         41.3\n 3 Africa     1962          1598.         43.3\n 4 Africa     1967          2050.         45.3\n 5 Africa     1972          2340.         47.5\n 6 Africa     1977          2586.         49.6\n 7 Africa     1982          2482.         51.6\n 8 Africa     1987          2283.         53.3\n 9 Africa     1992          2282.         53.6\n10 Africa     1997          2379.         53.6\n# ℹ 50 more rows\n\n\n \n\n\n8.1 Challenge 3\nCalculate the average life expectancy per country. Which has the longest average life expectancy and which has the shortest average life expectancy?\n\n\nClick for the solution\n\nFirst, let’s create a dataframe with the mean life expectancy by country:\n\nlifeExp_bycountry &lt;- gapminder %&gt;%\n   group_by(country) %&gt;%\n   summarize(mean_lifeExp = mean(lifeExp))\n\nThen, arrange that dataframe in two directions to see the countries with the longest and shortest life expectance – piping into head() as a bonus to only see the top n, here top 1:\n\nlifeExp_bycountry %&gt;%\n   arrange(mean_lifeExp) %&gt;%\n   head(n = 1)\n\n# A tibble: 1 × 2\n  country      mean_lifeExp\n  &lt;fct&gt;               &lt;dbl&gt;\n1 Sierra Leone         36.8\n\nlifeExp_bycountry %&gt;%\n   arrange(desc(mean_lifeExp)) %&gt;%\n   head(n = 1)\n\n# A tibble: 1 × 2\n  country mean_lifeExp\n  &lt;fct&gt;          &lt;dbl&gt;\n1 Iceland         76.5"
  },
  {
    "objectID": "3_dplyr.html#bonus-count-and-n",
    "href": "3_dplyr.html#bonus-count-and-n",
    "title": "Data frame manipulation with dplyr",
    "section": "9 Bonus: count() and n()",
    "text": "9 Bonus: count() and n()\nA very common operation is to count the number of observations for each group. The dplyr package comes with two related functions that help with this.\nFor instance, if we wanted to check the number of countries included in the dataset for the year 2002, we can use the count() function. It takes the name of one or more columns that contain the groups we are interested in, and we can optionally sort the results in descending order by adding sort = TRUE:\n\ngapminder %&gt;%\n    filter(year == 2002) %&gt;%\n    count(continent, sort = TRUE)\n\n# A tibble: 5 × 2\n  continent     n\n  &lt;fct&gt;     &lt;int&gt;\n1 Africa       52\n2 Asia         33\n3 Europe       30\n4 Americas     25\n5 Oceania       2\n\n\nIf we need to use the number of observations in calculations, the n() function is useful. It will return the total number of observations in the current group rather than counting the number of observations in each group within a specific column. For instance, if we wanted to get the standard error of the life expectancy per continent:\n\ngapminder %&gt;%\n  group_by(continent) %&gt;%\n  summarize(se_life = sd(lifeExp) / sqrt(n()))\n\n# A tibble: 5 × 2\n  continent se_life\n  &lt;fct&gt;       &lt;dbl&gt;\n1 Africa      0.366\n2 Americas    0.540\n3 Asia        0.596\n4 Europe      0.286\n5 Oceania     0.775"
  },
  {
    "objectID": "3_dplyr.html#learn-more",
    "href": "3_dplyr.html#learn-more",
    "title": "Data frame manipulation with dplyr",
    "section": "10 Learn more",
    "text": "10 Learn more\nThis material was adapted from this Carpentries lesson episode.\nIn your journey to become a skilled data frame wrangler in R, here are some additional topics that are very useful but beyond the scope of this workshop:\n\nJoining/merging – combining multiple dataframes based on one or more shared columns. This can be done with dplyr’s join_*() functions.\nPivoting/reshaping – moving between ‘wide’ and ‘long’ data formats with pivot_wider() and pivot_longer() – this is covered in episode 13 of our focal Carpentries lesson."
  },
  {
    "objectID": "4_ggplot.html",
    "href": "4_ggplot.html",
    "title": "Creating publication quality graphics with ggplot2",
    "section": "",
    "text": "In this episode, we will learn about how to create publication-quality graphics in R using the tidyverse package ggplot2. Plotting data is a very quick and easy way to understand the relationship between your variables."
  },
  {
    "objectID": "4_ggplot.html#the-grammar-of-graphics",
    "href": "4_ggplot.html#the-grammar-of-graphics",
    "title": "Creating publication quality graphics with ggplot2",
    "section": "1 The grammar of graphics",
    "text": "1 The grammar of graphics\nThe package ggplot2 applies a framework for plotting such that any plot can be built from the same basic building blocks. This very popular package is based on a system called the Grammar of Graphics by Leland Wilkinson which aims to create a grammatical rules for the development of graphics. It is part of a larger group of packages called “the tidyverse.”\nThe “gg” in ggplot stands for “grammar of graphics” and all plots share a common template. This is fundamentally different than plotting using a program like Excel, where you first pick your plot type, and then you add your data. With ggplot, you start with data, add a coordinate system, and then add “geoms,” which indicate what type of plot you want. A cool thing about ggplot is that you can add and layer different geoms together, to create a fully customized plot that is exactly what you want. If this sounds nebulous right now, that’s okay, we are going to talk more about this.\nSimplified, we will provide to R:\n\nour data\naesthetics mapped to variables - what connects the data to the graphics\nlayers - determine which type of plot we are going to make, what cordinate system we will use, what scales we want, and other important aspects of our plot\n\nYou can think about a ggplot as being composed of layers. You start with your data, and continue to add layers until you get the plot that you want. This might sound a bit abstract so I am going to talk through this with an example."
  },
  {
    "objectID": "4_ggplot.html#looking-at-our-data-and-getting-set-up",
    "href": "4_ggplot.html#looking-at-our-data-and-getting-set-up",
    "title": "Creating publication quality graphics with ggplot2",
    "section": "2 Looking at our data and getting set up",
    "text": "2 Looking at our data and getting set up\nBefore we plot, let’s look at the data we will use for this session. We are going to use the same gapminder data from one hour ago.\nIn case you don’t have it up from before, let’s load both the tidyverse and gapminder using the function library() so they are active.\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(gapminder)\n\nWe can use the function View() to look at our data. This opens our data sort of like how we might view it in Excel.\n\nView(gapminder)\n\nWe can also use the function str() or glimpse() to look at the structure of our data.\n\nstr(gapminder)\n\ntibble [1,704 × 6] (S3: tbl_df/tbl/data.frame)\n $ country  : Factor w/ 142 levels \"Afghanistan\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ continent: Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n $ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372 12881816 13867957 16317921 22227415 ...\n $ gdpPercap: num [1:1704] 779 821 853 836 740 ...\n\n\ngapminder is a tibble (very similar to a data frame), comprised of 1,704 rows and 6 columns. The columns are:\n\ncountry (a factor)\ncontinent (a factor)\nyear (an integer)\nlifeExp (a number)\npop (an integer)\n\nWe are going to use the function ggplot() when we want to make a ggplot.\n\n\n\n\n\n\nThe function vs the package\n\n\n\nNote, the function is called ggplot() and the package is called ggplot2.\n\n\nIf we want to learn how the function works, we can use the ? to find out more. Running the code below will open up the documentation page for the function ggplot() in the bottom right “Help” quadrant of RStudio.\n\n?ggplot()"
  },
  {
    "objectID": "4_ggplot.html#building-our-plot",
    "href": "4_ggplot.html#building-our-plot",
    "title": "Creating publication quality graphics with ggplot2",
    "section": "3 Building our plot",
    "text": "3 Building our plot\nWe can start by providing the data as the first argument to ggplot().\n\nggplot(data = gapminder)\n\n\n\n\nWe have a blank plot! We haven’t given enough information for R to know what we want to plot - we have simply told R what dataframe we will be using. We are getting the first “base” layer of the plot.\nInstead of providing the dataframe as the first argument to ggplot(), we can use the pipe %&gt;% (or the newer pipe |&gt;) that Jelmer taught us about. This “sends” the data into the next function. I will use this syntax for the rest of the workshop.\n\ngapminder %&gt;%\n  ggplot()\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nggplot(data = gapminder) and gapminder %&gt;% ggplot() are the same thing.\n\n\nIf we want to make a scatterplot to understand the relationship between GDP per capita (i.e., gdpPercap) and life expectancy (i.e., lifeExp), we can do so by setting x and y respectively within aes(), or our aesthetic mappings.\n\ngapminder %&gt;%\n  ggplot(mapping = aes(x = gdpPercap, y = lifeExp))\n\n\n\n\nOk! We don’t have a plot, per se, but we have more than we had before. We can now see that gdpPercap is on the x-axis (along with some numbers reflecting the range of our data), and lifeExp is on the y-axis (along with some numbers reflecting the range of our data).\n\n\n\n\n\n\nNote\n\n\n\nNote that the “mapping” part is actually not necessary.\n\n\n\ngapminder %&gt;%\n  ggplot(aes(x = gdpPercap, y = lifeExp))\n\n\n\n\nNow we need to tell R what geometry, or “geom” want to use. All of the “geoms” start with geom_*(), and we can see what they all are by starting to type geom and pressing tab.\nLet’s make a scatterplot here.\n\ngapminder %&gt;%\n  ggplot(aes(x = gdpPercap, y = lifeExp)) +\n  geom_point()\n\n\n\n\n\n\n3.1 Challenge 1\nModify the plot we’ve made so that you can see the relationship between life expectancy and year.\n\n\nClick for the solution\n\nMap x = year and y = lifeExp, and use geom_point() since we want a scatterplot.\n\ngapminder %&gt;%\n  ggplot(aes(x = year, y = lifeExp)) +\n  geom_point()\n\n\n\n\nNote the plot looks a little weird since each point is a country, so for every year, we have an average life expectancy for each country.\n\n\n\n\n3.2 Challenge 2\nModify to color your points by continent.\n\n\nNeed a hint?\n\nTry using the argument color within your aesthetic mappings.\n\n\n\nNeed another hint?\n\nTry setting color = continent within your aesthetic mappings.\n\n\n\nClick for the solution\n\n\ngapminder %&gt;%\n  ggplot(aes(x = year, y = lifeExp, color = continent)) + \n  geom_point()\n\n\n\n\nYou can better see here that each point is actually a different country now that they are colored by continent."
  },
  {
    "objectID": "4_ggplot.html#adding-more-layers",
    "href": "4_ggplot.html#adding-more-layers",
    "title": "Creating publication quality graphics with ggplot2",
    "section": "4 Adding more layers",
    "text": "4 Adding more layers\nInstead of making a scatter plot, we might want to make a line plot. Using ggplot this is as easy as changing out your geom.\n\ngapminder %&gt;%\n  ggplot(aes(x = year, y = lifeExp, color = continent)) +\n  geom_line()\n\n\n\n\nThe plot is jumping around a lot since for each year, we have life expectancy data for each country. Our plot here is not a summary of that data, but instead all of that data together, on top of itself.\nWe might want to have one line for each country, we can do this by specifying group = country within our aesthetic mappings.\n\ngapminder %&gt;% \n  ggplot(aes(x = year, y = lifeExp, color = continent, group = country)) +\n  geom_line()\n\n\n\n\nA nice thing about ggplot is that you don’t actually need to decide if you want to have lines or points, you can have both!\n\ngapminder %&gt;% \n  ggplot(aes(x = year, y = lifeExp, color = continent, group = country)) +\n  geom_line() +\n  geom_point()\n\n\n\n\nNow we see a point for each observation and each point and line is colored based on continent.\nYou can also set your mappings globally (within ggplot()) or locally (within a specific geom). Let’s see what the difference is. Let’s see what happens when we move color = continent into geom_point(aes(color = continent)).\n\ngapminder %&gt;% \n  ggplot(aes(x = year, y = lifeExp, group = country)) +\n  geom_point(aes(color = continent)) +\n  geom_line()\n\n\n\n\nWe can see that now only the points are colored by continent, and the lines are all black (the default color for one group).\n\n\n4.1 Challenge 3\nChange the order of the point and line layers - what happens?\n\n\nClick for the solution\n\nPoints then lines (points are on the bottom)\n\ngapminder %&gt;%\n  ggplot(aes(x = year, y = lifeExp, group = country)) +\n  geom_point() +\n  geom_line(aes(color = continent))\n\n\n\n\nLines then points (lines are on the bottom)\n\ngapminder %&gt;%\n  ggplot(aes(x = year, y = lifeExp, group = country)) +\n  geom_line(aes(color = continent)) +\n  geom_point() \n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe layers are added in the order you indicate, so if you change the order, your plot will change. You can see because geom_line() comes below geom_point(), the lines are placed on top of the points."
  },
  {
    "objectID": "4_ggplot.html#transformations-and-statistics",
    "href": "4_ggplot.html#transformations-and-statistics",
    "title": "Creating publication quality graphics with ggplot2",
    "section": "5 Transformations and statistics",
    "text": "5 Transformations and statistics\nSometimes we might want to apply some kind of transformation to our data while plotting so we can better see relationships between our variables.\nLet’s start with a base plot to see the relationship between GDP per capita (gdpPercap) and life expectancy (lifeExp).\n\ngapminder %&gt;%\n  ggplot(aes(x = gdpPercap, y = lifeExp)) +\n  geom_point()\n\n\n\n\nThe presence of some outliers for gdpPercap make it hard to see this relationship. We can try log base 10 transforming the x-axis to see if this helps using a scale_*() function.\n\ngapminder %&gt;%\n  ggplot(aes(x = gdpPercap, y = lifeExp)) +\n  geom_point() +\n  scale_x_log10() # log 10 scales the x axis\n\n\n\n\nI can also make our points a little bit transparent to ease our overplotting problem (where too many point are on top of each other, making each point hard to see) by setting alpha =. Alpha ranges from 0 (totally transparent) to 1 (totally opaque). Note that I alpha = 0.5 outside the aes() function - we are not mapping alpha to some variable, we are simply setting what alpha should be.\n\ngapminder %&gt;%\n  ggplot(aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) + # not inside aes\n  scale_x_log10() # log10 transform the x-axis\n\n\n\n\nNow we can better see the parts of the plot that are very dark are where there are a lot of data points.\nWe can also add a smoothed line of fit to our data by setting method = \"lm\" within geom_smooth() to fit a linear model.\n\ngapminder %&gt;%\n  ggplot(aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) + # not inside the aes\n  scale_x_log10() +\n  geom_smooth(method = \"lm\") # smooth with a linear model ie \"lm\"\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nWe can adjust the thickness of the line by setting linewidth within geom_smooth(), and turn off the confidence interval by setting se = FALSE.\n\ngapminder %&gt;%\n  ggplot(aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) + # not inside the aes\n  scale_x_log10() +\n  geom_smooth(method = \"lm\", # smooth with a linear model ie \"lm\"\n              linewidth = 3, # increase thickness of the line\n              se = FALSE) # turn off plotting of a confident internal\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n5.1 Challenge 4A\nModify the color and the size of the points in the previous example. You’ll also probably want to make the linewidth less ridiculous.\n\n\nNeed a hint?\n\nDon’t put color and size inside aes().\n\n\n\nWant another hint?\n\nThe equivalent of linewidth for points is size.\n\n\n\nClick for the solution\n\n\ngapminder %&gt;%\n  ggplot(aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5, color = \"purple\", size = 0.5) + # outside the aes\n  scale_x_log10() +\n  geom_smooth(method = \"lm\", linewidth = 1) \n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n5.2 Challenge 4B\nModify the plot from 4A so points are a different shape and colored by continent with new trendlines\n\n\nNeed a hint?\n\nDon’t put color and size inside aes().\n\n\n\nWant another hint?\n\nThe equivalent of linewidth for points is size.\n\n\n\nClick for the solution\n\nAll points are now triangles. You can find info on the shape codes here.\n\ngapminder %&gt;%\n  ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point(shape = 17, # 17 is a closed triangle\n             alpha = 0.5) + \n  scale_x_log10() +\n  geom_smooth(method = \"lm\", linewidth = 1) # smooth with a linear model ie \"lm\"\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nAll points are now open triangles, we are setting continent to fill and making the outline black. Note that only shapes 21-25 can accept both a color (outside) and fill (inside). Otherwise, they only accept color.\n\ngapminder %&gt;%\n  ggplot(aes(x = gdpPercap, y = lifeExp, fill = continent)) +\n  geom_point(shape = 24, # open triangle\n             alpha = 0.5, \n             color = \"black\") + # color controls outside, fill controls inside\n  scale_x_log10() +\n  geom_smooth(method = \"lm\", linewidth = 1) # smooth with a linear model ie \"lm\"\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nMapping shape to continent\n\ngapminder %&gt;%\n  ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point(aes(shape = continent), alpha = 0.5) + \n  scale_x_log10() +\n  geom_smooth(method = \"lm\", linewidth = 1) # smooth with a linear model ie \"lm\"\n\n`geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "4_ggplot.html#multi-panel-figures",
    "href": "4_ggplot.html#multi-panel-figures",
    "title": "Creating publication quality graphics with ggplot2",
    "section": "6 Multi-panel figures",
    "text": "6 Multi-panel figures\nSmall multiples are a useful way to look at data across the same scale to understand patterns.\nLet’s say we want to understand how life expectancy changes over time throughout the Americas? Instead of making an individual plot for each country, we can use facet_wrap() to have ggplot make our plots all at once.\nFirst let’s use what Jelmer taught us to filter for only the observations from the Americas.\n\ngapminder_americas &lt;- gapminder %&gt;%\n  filter(continent == \"Americas\")\n\nThen, this new data frame gapminder_americas can be the data for our next plot. Let’s look first without faceting.\n\ngapminder_americas %&gt;%\n  ggplot(aes(x = year, y = lifeExp, group = country)) +\n  geom_line()\n\n\n\n\nFaceting allows us to better see each country on its own.\n\ngapminder_americas %&gt;%\n  ggplot(aes(x = year, y = lifeExp)) +\n  geom_line() +\n  facet_wrap(vars(country)) + # make facets by country\n  theme(axis.text.x = element_text(angle = 45)) # years on the x on a 45 deg angle"
  },
  {
    "objectID": "4_ggplot.html#modifying-text",
    "href": "4_ggplot.html#modifying-text",
    "title": "Creating publication quality graphics with ggplot2",
    "section": "7 Modifying text",
    "text": "7 Modifying text\nThe plots we’ve made so far could really benefit from some better labels. We can set what we want or plot labels to be as arguments in labs().\n\ngapminder_americas %&gt;%\n  ggplot(aes(x = year, y = lifeExp)) +\n  geom_line() +\n  facet_wrap(vars(country)) + # make facets by country\n  theme(axis.text.x = element_text(angle = 45)) + # years on the x on a 45 deg angle\n  labs(x = \"Year\",              # x axis title\n       y = \"Life expectancy\",   # y axis title\n       title = \"Figure 1. Life expectancy in the Americas from 1952-2007\", # main title of figure\n      )"
  },
  {
    "objectID": "4_ggplot.html#exporting-a-plot",
    "href": "4_ggplot.html#exporting-a-plot",
    "title": "Creating publication quality graphics with ggplot2",
    "section": "8 Exporting a plot",
    "text": "8 Exporting a plot\nOften we want to take our plot we have made using R and save it for use someplace else. You can export using the Export button in the Plots pane (bottom right) but you are limited on the parameters for the resulting figure.\nWe can do this with more control using the function ggsave().\nFirst we will save our plot as an object using the assignment operator &lt;-, here as life_exp_americas_plot.\n\nlife_exp_americas_plot &lt;- gapminder_americas %&gt;%\n  ggplot(aes(x = year, y = lifeExp)) +\n  geom_line() +\n  facet_wrap(vars(country)) + # make facets by country\n  theme(axis.text.x = element_text(angle = 45)) + # years on the x on a 45 deg angle\n  labs(x = \"Year\", # x axis title\n       y = \"Life expectancy\", # y axis title\n       title = \"Figure 1. Life expectancy in the Americas from 1952-2007\", # main title of figure\n      )\n\nThen we can save it. I am indicating here to save the plot in a folder called results in my working directory, as a file called lifeExp.png. If you want your file to go within a folder, you have to first create that folder.\n\nggsave(filename = \"results/lifeExp.png\", # file path and name\n       plot = life_exp_americas_plot,  # what to save\n       width = 18, \n       height = 12, \n       dpi = 300, # dots per inch,  ie resolution\n       units = \"cm\") # units for width and height\n\n\n\n\n\n\n\nNote\n\n\n\nTo learn more about the arguments in ggsave() you can always run ?ggsave().\n\n\n\n8.1 Challenge 5\nCreate some box plots that compare life expectancy between the continents over the time period provided. Try and make your plot look nice, add labels and stuff!\n\n\nNeed a hint?\n\nThe geom for making a boxplot is geom_boxplot().\n\n\n\nWant another hint?\n\nSet labels within labs(). Adjust theming with theme(). Check out the complete themes.\n\n\n\nClick for the solution\n\n\ngapminder %&gt;%\n  ggplot(aes(x = continent, y = lifeExp, fill = continent)) +\n  geom_boxplot() +\n  facet_wrap(vars(year)) +\n  theme_classic() + # my favorite complete theme \n  theme(axis.title.x = element_blank(), # remove x-axis title\n        axis.text.x = element_blank(), # remove x-axis labels\n        axis.ticks.x = element_blank()) + # remove x-axis ticks\n  labs(y = \"Life Expectancy (years)\",\n       fill = \"Continent\") # change the label on top of the legend"
  },
  {
    "objectID": "1_intro.html",
    "href": "1_intro.html",
    "title": "Introduction to R and RStudio",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "2_data-structures.html#introduction",
    "href": "2_data-structures.html#introduction",
    "title": "R’s data structures and data types",
    "section": "1 Introduction",
    "text": "1 Introduction\nIn this session, we will learn about R’s data structures and data types.\n\nData structures are the kinds of objects that R can store data in. Here, we will cover the two most common ones: vectors and data frames.\nData types are how R distinguishes between different kinds of data like numbers and character strings. Here, we’ll talk about the 4 main data types: character, integer, double, and logical.\n\nDuring this session, I will write my code in a script and send it to the console from there. So, I will start by opening a new script (+ symbol in toolbar at the top =&gt; “R Script”, or “File” =&gt; “New file” =&gt; R Script”), and I will save it straight away as data-structures.R in a folder on my Desktop (create a new folder there or anywhere else for this workshop, if you haven’t done so already).\nI will also change my Pane Layout to have the script and the console side-by-side."
  },
  {
    "objectID": "2_data-structures.html#data-structure-1-vectors",
    "href": "2_data-structures.html#data-structure-1-vectors",
    "title": "R’s data structures and data types",
    "section": "2 Data structure 1: Vectors",
    "text": "2 Data structure 1: Vectors\nThe first data structure we will explore is the simplest: the vector. A vector in R is essentially a list of one or more items. Moving forward, we’ll call these individual items “elements”.\n\n2.1 Single-element vectors and quoting\nVectors can consist of just a single element, so in each of the two lines of code below, a vector is in fact created:\n\nvector1 &lt;- 8\nvector2 &lt;- \"panda\"\n\nTwo things are worth noting about the second example with a character string:\n\n“panda” constitutes one element, not 5 (its number of letters).\nWe have to quote the string (either double or single quotes are fine, with the former more common). This is because unquoted character strings are interpreted as R objects – for example, vector1 and vector2 above are objects, and should be referred to without quotes:\n\n\n# [Note that R will show auto-complete options after you type 3 characters]\nvector1\n\n[1] 8\n\nvector2\n\n[1] \"panda\"\n\n\nConversely, the below doesn’t work, because there is no object called panda:\n\nvector_fail &lt;- panda\n\nError: object 'panda' not found\n\n\nAs a side note, in the R console, you can press the up arrow to retrieve the previous command, and do so repeatedly to go back to older commands. Let’s practice that to get back our vector1 command:\n\nvector1\n\n[1] 8\n\n\n\n\n\n2.2 Multi-element vectors\nA common way to make vectors with multiple elements is to use the c (combine) function:\n\nc(2, 6, 3)\n\n[1] 2 6 3\n\n\n(In the above example, I didn’t assign the vector to an object, but a vector was created nevertheless.)\nc() can also append elements to an existing vector:\n\nvector_append &lt;- c(\"vhagar\", \"meleys\")\nvector_append\n\n[1] \"vhagar\" \"meleys\"\n\nc(vector_append, \"balerion the dread\")\n\n[1] \"vhagar\"             \"meleys\"             \"balerion the dread\"\n\n\nTo create vectors with series of numbers, a couple of shortcuts are available. First, you can make series of whole numbers with the : operator:\n\n1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nSecond, you can use a function like seq() for fine control over the sequence:\n\nvector_seq &lt;- seq(from = 6, to = 8, by = 0.2)\nvector_seq\n\n [1] 6.0 6.2 6.4 6.6 6.8 7.0 7.2 7.4 7.6 7.8 8.0\n\n\n\n\n\n2.3 Vectorization\nIn R, you can do the following:\n\nvector_seq * 2\n\n [1] 12.0 12.4 12.8 13.2 13.6 14.0 14.4 14.8 15.2 15.6 16.0\n\n\nAbove, we multiplied every single element in vector_seq by 2. Another way of looking at this is that 2 was recycled as many times as necessary to operate on each element in vector_seq. We call this “vectorization” and this is a key feature of the R language. This behavior may seem intuitive, but in most languages you’d need a special construct like a loop to operate on each value in a vector.\n(Alternatively, you may have expected this code to repeat vector_seq twice, but this did not happen! R has the function rep() for that. For more about vectorization, see episode 9 from our Carpentries lesson.)\n \n\n\n\n2.4 Challenge 1\nA. Start by making a vector x with the whole numbers 1 through 26. Then, subtract 0.5 from each element in the vector and save the result in vector y. Check your results by printing both vectors.\n\n\nClick for the solution\n\n\nx &lt;- 1:26\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26\n\ny &lt;- x - 0.5\ny\n\n [1]  0.5  1.5  2.5  3.5  4.5  5.5  6.5  7.5  8.5  9.5 10.5 11.5 12.5 13.5 14.5\n[16] 15.5 16.5 17.5 18.5 19.5 20.5 21.5 22.5 23.5 24.5 25.5\n\n\n\n\nB. What do you think will be the result of the following operation?\n\n1:5 * 1:5\n\n\n\nClick for the solution\n\n\n1:5 * 1:5\n\n[1]  1  4  9 16 25\n\n\nBoth vectors are of length 5 which will lead to “element-wise matching”: the first element in the first vector will be multiplied with the first element in the second vector, the second element in the first vector will be multiplied with the second element in the second vector, and so on.\n\n\n\n\n\n2.5 Exploring vectors\nR has many built-in functions to get information about vectors and other types of objects, such as:\n\nhead() and tail() to get the first few and last few elements, respectively:\n\n\nhead(vector_seq)\n\n[1] 6.0 6.2 6.4 6.6 6.8 7.0\n\n# Both head and tail take an argument `n` to specify the number of elements to print:\nhead(vector_seq, n = 2)\n\n[1] 6.0 6.2\n\ntail(vector_seq)\n\n[1] 7.0 7.2 7.4 7.6 7.8 8.0\n\n\n\n\nlength() to get the number of elements:\n\n\nlength(vector_seq)\n\n[1] 11\n\n\n\n\nFunctions like sum() and mean(), if the vector contains numbers:\n\n\n# sum() will sum the values of all elements\nsum(vector_seq)\n\n[1] 77\n\n# mean() will compute the mean (average) across all elements\nmean(vector_seq)\n\n[1] 7\n\n\n\n\n\n2.6 Extracting elements from vectors\nWe can extract elements of a vector by “indexing” them using bracket notation. Here are a couple of examples:\n\nGet the second element:\n\n\nvector_seq[2]\n\n[1] 6.2\n\n\n\nGet the elements 2 through 5:\n\n\nvector_seq[2:5]\n\n[1] 6.2 6.4 6.6 6.8\n\n\n\nGet the first and eight elements:\n\n\nvector_seq[c(1, 8)]\n\n[1] 6.0 7.4\n\n\nTo change an element in a vector, use the bracket on the other side of the arrow:\n\n# Change the first element to '30':\nvector_seq[1] &lt;- 30\nvector_seq\n\n [1] 30.0  6.2  6.4  6.6  6.8  7.0  7.2  7.4  7.6  7.8  8.0"
  },
  {
    "objectID": "2_data-structures.html#data-structure-2-data-frames",
    "href": "2_data-structures.html#data-structure-2-data-frames",
    "title": "R’s data structures and data types",
    "section": "3 Data structure 2: Data frames",
    "text": "3 Data structure 2: Data frames\n\n3.1 R stores tabular data in “data frames”\nOne of R’s most powerful features is its built-in ability to deal with tabular data – i.e., data with rows and columns like you are familiar with from spreadsheets.\nIn R, tabular data is stored in objects that are called “data frames”. Data frames are the second and final R data structure that we’ll cover in some depth.\nLet’s start by making a toy data frame with some information about 3 cats:\n\ncats &lt;- data.frame(\n  coat = c(\"calico\", \"black\", \"tabby\"),\n  weight = c(2.1, 5.0, 3.2),\n  likes_string = c(1, 0, 1)\n  )\n\ncats\n\n    coat weight likes_string\n1 calico    2.1            1\n2  black    5.0            0\n3  tabby    3.2            1\n\n\nWhat we really did above is to create 4 vectors, all of length 3, and pasted them side-by-side to create a data frame. We also gave each vector a name, which became the column names.\nThe resulting data frame has 3 rows (one for each cat) and 4 columns (each with a type of info about the cats, like coat color).\nIn data frames, typically:\n\nSeparate variables (e.g. coat color, weight) are spread across columns,\nSeparate “observations” (e.g., cat/person, sample) are spread across rows.\n\n\n\n\n3.2 Extracting columns from a data frame\nWe can extract individual columns from a data frame by specifying their names using the $ operator:\n\ncats$weight\n\n[1] 2.1 5.0 3.2\n\ncats$coat\n\n[1] \"calico\" \"black\"  \"tabby\" \n\n\nThis kind of operation will return a vector. We won’t go into more detail about exploring (or manipulating) data frames, because we will do that with the dplyr package in the next episode."
  },
  {
    "objectID": "2_data-structures.html#data-types",
    "href": "2_data-structures.html#data-types",
    "title": "R’s data structures and data types",
    "section": "4 Data types",
    "text": "4 Data types\n\n4.1 R’s main Data Types\nR distinguishes between several kinds of data, such as between character strings and numbers, in a formal way, and uses several “data types” to do so. The behavior of R in various operations will heavily depend on the data type – for example, the below fails:\n\n\"valerion\" * 5\n\nError in \"valerion\" * 5: non-numeric argument to binary operator\n\n\nWe can ask what type of data something is in R using the typeof() function:\n\ntypeof(\"valerion\")\n\n[1] \"character\"\n\n\nSo the data type is character, which we commonly refer to as character strings or strings. In formal terms, R will not allow us to perform mathematical functions on vectors of type character.\nThe character data type typically contains letters but can have any character, including numbers, as long as it is quoted:\n\ntypeof(\"5\")\n\n[1] \"character\"\n\n\nBesides character, the other 3 common data types are double (also called numeric), integer, and logical.\n\ndouble / numeric – numbers that can have decimal points:\n\n\ntypeof(3.14)\n\n[1] \"double\"\n\n\n\ninteger – whole numbers only:\n\n\ntypeof(1:3)\n\n[1] \"integer\"\n\n\n\nlogical (either TRUE or FALSE – unquoted!):\n\n\ntypeof(TRUE)\n\n[1] \"logical\"\n\ntypeof(FALSE)\n\n[1] \"logical\"\n\n\n\n\n\n\n4.2 Challenge 2\nWhat do you expect each of the following to produce?\n\ntypeof(\"TRUE\")\ntypeof(banana)\n\n\n\nClick for the solution\n\n\n\"TRUE\" is character because of the quotes around it.\nRecall the earlier example: this returns an error because the object banana does not exist.\n\n\n\n\n\n\n4.3 Vectors and data frame columns can only have 1 data type\nVectors and individual columns in data frames can only be composed of a single data type. R will silently pick the “best-fitting” data type when you enter or read data into a data frame. Let’s see what the data types are in our cats data frame:\n\nstr(cats)\n\n'data.frame':   3 obs. of  3 variables:\n $ coat        : chr  \"calico\" \"black\" \"tabby\"\n $ weight      : num  2.1 5 3.2\n $ likes_string: num  1 0 1\n\n\n\nThe coat column is character, abbreviated chr.\nThe weight column is double/numeric, abbreviated num.\nThe likes_string column is integer, abbreviated int.\n\n\n\n\n\n4.4 Challenge 3\nGiven what we’ve learned so far, what type of vector do you think the following will produce?\n\nquiz_vector &lt;- c(2, 6, \"3\")\n\n\n\nClick for the solution\n\nIt produces a character vector:\n\nquiz_vector\n\n[1] \"2\" \"6\" \"3\"\n\ntypeof(quiz_vector)\n\n[1] \"character\"\n\n\nWe’ll talk about what happened here in the next section.\n\n\n\n\n\n4.5 Automatic Type Coercion\nWhat happened in the code from the challenge above is something called type coercion, which can be the source of many surprises, and is one reason we need to be aware of the basic data types and how R will interpret them. When R encounters a mix of types (here double and character) to be combined into a single vector, it will force them all to be the same type.\nHere is another example:\n\ncoercion_vector &lt;- c(\"a\", TRUE)\ncoercion_vector\n\n[1] \"a\"    \"TRUE\"\n\ntypeof(coercion_vector)\n\n[1] \"character\"\n\n\nLike in two examples we’ve seen, you will most commonly run into situations where numbers or logicals are converted to characters.\nThe nitty-gritty of type coercion aside, the point is: if your data doesn’t look like what you thought it was going to look like, type coercion may well be to blame!\n\n\n\n4.6 Manual Type Conversion\nLuckily, you are not simply at the mercy of whatever R decides to do automatically, but can convert vectors at will using the as. group of functions (here, try RStudio’s auto-complete function: Type “as.” and then press the TAB key):\n\nas.double(c(\"0\", \"2\", \"4\"))\n\n[1] 0 2 4\n\nas.character(c(0, 2, 4))\n\n[1] \"0\" \"2\" \"4\"\n\n\nAs another example, in our cats data, likes_string is numeric, but the 1s and 0s actually represent TRUE and FALSE (a common way of representing them).\n\ncats$likes_string\n\n[1] 1 0 1\n\n\nWe could use the logical data type here, by converting this column with the as.logical() function, which will turn 0’s into FALSE and everything else, including 1, to TRUE:\n\nas.logical(cats$likes_string)\n\n[1]  TRUE FALSE  TRUE\n\n\nAs you may have guessed, though, not all type conversions are possible:\n\nas.double(\"kiwi\")\n\nWarning: NAs introduced by coercion\n\n\n[1] NA\n\n\n(NA is R’s way of denoting missing data.)"
  },
  {
    "objectID": "2_data-structures.html#factors",
    "href": "2_data-structures.html#factors",
    "title": "R’s data structures and data types",
    "section": "5 Factors",
    "text": "5 Factors\nIn R, categorical data, like different treatments in an experiment, can be stored as “factors”. Factors are useful for statistical analyses and also for plotting, the latter because you can specify a custom order among the so-called “levels” of the factor.\n\ndiet_vec &lt;- c(\"high\", \"medium\", \"low\", \"low\", \"medium\", \"high\")\nfactor(diet_vec)\n\n[1] high   medium low    low    medium high  \nLevels: high low medium\n\n\nIn the example above, we turned a regular vector into a factor. The levels are sorted alphabetically by default, but we can manually specify an order that makes more sense and that would carry through if we would plot data associated with this factor:\n\ndiet_fct &lt;- factor(diet_vec, levels = c(\"low\", \"medium\", \"high\"))\ndiet_fct\n\n[1] high   medium low    low    medium high  \nLevels: low medium high\n\n\nFor most intents and purposes, it makes sense to think of factors as another data type, even though technically, it is a kind of data structure build on the integer data type:\n\ntypeof(diet_fct)\n\n[1] \"integer\"\n\n\n\n5.1 Challenge 4\nAn important part of every data analysis is cleaning input data. Here, you will clean a cat data set that has an added observation with a problematic data entry.\nStart by creating the new data frame:\n\ncats_v2 &lt;- data.frame(\n  name = c(\"Luna\", \"Misty\", \"Bella\", \"Oliver\"),\n  coat = c(\"calico\", \"black\", \"tabby\", \"tabby\"),\n  weight = c(2.1, 5.0, 3.2, \"2.3 or 2.4\"),\n  likes_string = c(1, 0, 1, 1)\n)\n\nThen move on to the tasks below, filling in the blanks (_____) and running the code:\n\n# 1. Explore the data frame,\n#    including with an overview that shows the columns' data types:\ncats_v2\n_____(cats_v2)\n\n# 2. The \"weight\" column has the incorrect data type _____.\n#    The correct data type is: _____.\n\n# 3. Correct the 4th weight with the mean of the two given values,\n#    then print the data frame to see the effect:\ncats_v2$weight[4] &lt;- 2.35\ncats_v2\n\n# 4. Convert the weight column to the right data type:\ncats_v2$weight &lt;- _____(cats_v2$weight)\n\n# 5. Calculate the mean weight of the cats:\n_____\n\n\n\n\nClick for the solution\n\n\n# 1. Explore the data frame,\n#    including with an overview that shows the columns' data types:\ncats_v2\n\n    name   coat     weight likes_string\n1   Luna calico        2.1            1\n2  Misty  black          5            0\n3  Bella  tabby        3.2            1\n4 Oliver  tabby 2.3 or 2.4            1\n\nstr(cats_v2)\n\n'data.frame':   4 obs. of  4 variables:\n $ name        : chr  \"Luna\" \"Misty\" \"Bella\" \"Oliver\"\n $ coat        : chr  \"calico\" \"black\" \"tabby\" \"tabby\"\n $ weight      : chr  \"2.1\" \"5\" \"3.2\" \"2.3 or 2.4\"\n $ likes_string: num  1 0 1 1\n\n# 2. The \"weight\" column has the incorrect data type CHARACTER.\n#    The correct data type is: DOUBLE.\n\n# 3. Correct the 4th weight data point with the mean of the two given values,\n#    then print the data frame to see the effect:\ncats_v2$weight[4] &lt;- 2.35\ncats_v2\n\n    name   coat weight likes_string\n1   Luna calico    2.1            1\n2  Misty  black      5            0\n3  Bella  tabby    3.2            1\n4 Oliver  tabby   2.35            1\n\n# 4. Convert the weight column to the right data type:\ncats_v2$weight &lt;- as.double(cats_v2$weight)\n\n# 5. Calculate the mean weight of the cats:\nmean(cats_v2$weight)\n\n[1] 3.1625"
  },
  {
    "objectID": "2_data-structures.html#learn-more",
    "href": "2_data-structures.html#learn-more",
    "title": "R’s data structures and data types",
    "section": "6 Learn more",
    "text": "6 Learn more\nThis material was adapted from this Carpentries lesson episode. To learn more about data types and data structures, see this episode from a separate Carpentries lesson."
  },
  {
    "objectID": "2_data-structures.html#bonus",
    "href": "2_data-structures.html#bonus",
    "title": "R’s data structures and data types",
    "section": "7 Bonus",
    "text": "7 Bonus\n\n7.1 Writing and reading tabular data\nLet’s practice writing and reading data. First, we will write data to file that is in our R environment, and then we will read data that is in a file into our R environment.\nVia functions from an add-on package, R can interact with Excel spreadsheet files, but keeping your data in plain-text files generally benefits reproducibility. Tabular plain text files can be stored using a Tab as the delimiter (these are often called TSV files, and stored with a .tsv extension) or with a comma as the delimiter (these are often called CSV files, and stored with a .csv extension).\nWe will use the write.csv function to write the cats data frame to a CSV file in our current working directory:\n\nwrite.csv(x = cats, file = \"feline-data.csv\", row.names = FALSE)\n\nHere, we are explicitly naming all arguments, which can be good practice for clarity:\n\nx is the R object to write to file\nfile is the file name (which can include directories/folders)\nWe are setting row.names = FALSE to avoid writing the row names, which by default are just row numbers.\n\nIn RStudio’s Files pane, let’s find our new file, click on it, and then click “View File”. That way, the file will open in the editor, where it should look like this:\n\"name\",\"coat\",\"weight\",\"likes_string\"\n\"Luna\",\"calico\",2.1,1\n\"Misty\",\"black\",5,0\n\"Bella\",\"tabby\",3.2,1\n(Note that R adds double quotes \"...\" around strings – if you want to avoid this, add quote = FALSE to write.csv().)\n\nLet’s also practice reading data from a file into R. We’ll use the read.csv() function for the file we just created:\n\ncats_reread &lt;- read.csv(file = \"feline-data.csv\")\ncats_reread\n\n    coat weight likes_string\n1 calico    2.1            1\n2  black    5.0            0\n3  tabby    3.2            1\n\n\nA final note: write.csv() and read.csv() are really just two more specific convenience versions of the write/read.table() functions, which can be used to write and read in tabular data in any kind of plain text file.\n\n\n7.2 A few other data structures in R\nWe did not go into details about R’s other data structures, which are less common than vectors and data frames. Two that are worth mentioning briefly, though, are:\n\nMatrix, which can be convenient when you have tabular data that is exclusively numeric (excluding names/labels).\nList, which is more flexible (and complicated) than vectors: it can contain multiple data types, and can also be hierarchically structured.\n\n\n\n\n7.3 Missing values (NA)\nR has a concept of missing data, which is important in statistical computing, as not all information/measurements are always available for each sample.\nIn R, missing values are coded as NA (and this is not a character string, so it is not quoted):\n\n# This vector will contain one missing value\nvector_NA &lt;- c(1, 3, NA, 7)\nvector_NA\n\n[1]  1  3 NA  7\n\n\nThe main reason to bring this up so early in your R journey is that you should be aware of the following: many functions that operate on vectors will return NA if any of the elements in the vector is NA:\n\nsum(vector_NA)\n\n[1] NA\n\n\nThe way to get around this is by setting na.rm = TRUE in such functions, for example:\n\nsum(vector_NA, na.rm = TRUE)\n\n[1] 11\n\n\n\n\n\n7.4 More on the logical data type\nIf you think 1/0 could be more useful than TRUE/FALSE because it’s easier to count the number of cases something is true or false, consider:\n\nTRUE + TRUE\n\n[1] 2\n\n\nSo, logicals can be used as if they were numbers, in which case FALSE represents 0 and TRUE represents 1."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Workshop on R for Reproducibility",
    "section": "",
    "text": "Schedule\n\n\n\nTime\nInstructor\nTopic & link\n\n\n\n\nBefore starting\n-\nInstall and set up R and RStudio\n\n\n9:00 - 9:20 am\nall\nPre-workshop survey (if only attending today), intro, logistics\n\n\n9:20 - 10:15 am\nHoracio\n1: Introduction to R and RStudio\n\n\n10:15 - 10:30 am\n-\nBreak\n\n\n10:30 - 11:30 am\nJelmer\n2: R data structures\n\n\n11:30 am - 12:15 pm\n-\nLunch\n\n\n12:15 - 1:15 pm\nJelmer\n3: Data manipulation with dplyr\n\n\n1:15 - 1:30 pm\n-\nBreak\n\n\n1:30 - 2:50 pm\nJessica\n4: Visualization with ggplot2\n\n\n2:50 - 3:00 pm\n-\nPost-workshop survey\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "readme.html",
    "href": "readme.html",
    "title": "1 Ohio State R for Reproducible Research Carpentries Workshop Feb 11, 2025",
    "section": "",
    "text": "1 Ohio State R for Reproducible Research Carpentries Workshop Feb 11, 2025\nThis is source repo for the website for the hands-on “R for Reproducibility” workshop taught at Ohio State University on February 11th, 2025.\nThis workshop is taught by the organizers of Ohio State’s Code Club, Jelmer Poelstra, Horacio Lopez-Nicora, and Jessica Cooperstone.\nYou can find the website with course materials at https://osu-codeclub.github.io/carpentries-feb-2025/.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About this website",
    "section": "",
    "text": "This is the website for the hands-on “R for Reproducibility” workshop taught at Ohio State University on February 11th, 2025.\n\n\nPractical info about the workshop\nR is a programming language that is especially powerful for data exploration, visualization, and statistical analysis. During this workshop, participants will learn the basics of R and RStudio, and how to use R for reproducible data manipulation and visualization.\nIf you are affiliated with Ohio State University in any capacity, you can attend this workshop for free by registering here.\nThere are no prerequisites: this workshop is suitable for complete beginners in R and in coding in general.\nYou can attend the workshop either online via Zoom or in-person at co-learning sites in Columbus or Wooster (information will be sent after registration).\n\n\n\nInstructors and organizers\nThis workshop is taught by the organizers of OSU Code Club:\n\nHoracio Lopez-Nicora – Assistant Professor in the department of Plant Pathology\nJelmer Poelstra – Bioinformatics & Microscopy Lead at the CFAES Molecular and Cellular Imaging Center (MCIC)\nJessica Cooperstone – Associate Professor in the departments of Horticulture & Crop Science, and Food Science & Technology\n\nThe following helpers will be assisisting participants:\n\nMenuka Bhandari\nFiama Guevara-Guillen\nMelanie Medina-Lopez\nDhanashree\nKelsey Badger\nMatthew Thompson\n…\n\nThis workshop is organized by Kelsey Badger at the OSU Research Commons, Matthew Thompson and Elizabeth Campolongo at the OSU Imageomics Institute, and the abovementioned instructors, and is part of OSU’s 2025 International Love Data Week activities.\nThis is a Carpentries workshop. The Carpentries project comprises the Software Carpentry, Data Carpentry, and Library Carpentry communities of Instructors, Trainers, Maintainers, helpers, and supporters who share a mission to teach foundational computational and data science skills to researchers.\nThe material on this website has been adapted from the R for Reproducible Scientific Analysis Software Carpentry lesson.\n\n\n\n\n Back to top"
  }
]